# Meal Planner Service - CRUD Operations Explanation

## Why Do We Need CRUD Operations for Meal Plans?

### The Problem We're Solving

In a rural healthcare setting for women's health, meal planning isn't just about showing recommendations once and forgetting them. Here's why we need full CRUD (Create, Read, Update, Delete) operations:

---

## 1. **CREATE - Generate New Meal Plans**

### Why It's Needed:
- **Daily Fresh Recommendations**: Users need new meal plans regularly (daily/weekly)
- **Personalized Generation**: Different recommendations based on:
  - Pregnancy stage (trimester)
  - Health conditions
  - Dietary restrictions
  - Budget constraints
  - Seasonal ingredient availability
- **AI-Powered Variety**: Each generation creates unique combinations to avoid monotony

### Real-World Scenario:
```
Day 1: User gets breakfast/lunch/dinner/snack suggestions
Day 2: User wants fresh ideas → Generate new meal plan
Week 2: Pregnancy progresses → Generate updated recommendations
```

### Technical Implementation:
```typescript
POST /api/mealplan/generate
Body: {
  userId: "user_123",
  userProfile: "Second trimester, vegetarian, low income"
}
```

---

## 2. **READ - Retrieve Meal Plans**

### Why It's Needed:

#### A. **View Current Plan** (Get by ID)
- User wants to see today's meal plan
- Review what meals were suggested
- Check preparation steps while cooking
- Share plan with family members

#### B. **Browse History** (Get All Plans)
- See past meal plans
- Find favorite meals that worked well
- Track what they've been eating
- Learn from successful combinations

### Real-World Scenarios:

**Scenario 1: Cooking Time**
```
User is in kitchen → Opens app → Views meal plan
→ Reads step-by-step instructions → Cooks the meal
```

**Scenario 2: Weekly Review**
```
User wants to plan shopping → Reviews past week's meals
→ Sees which ingredients are commonly needed
→ Makes efficient shopping list
```

**Scenario 3: Doctor Consultation**
```
Doctor asks: "What have you been eating?"
User shows: Last week's meal history from app
Doctor reviews: Nutrition quality and variety
```

### Technical Implementation:
```typescript
// Get specific meal plan
GET /api/mealplan/:id

// Get user's meal plan history
GET /api/mealplan?userId=user_123&limit=10
```

---

## 3. **UPDATE - Modify Meal Plans**

### Why It's Needed:

#### A. **Mark Preferred Suggestions**
- Each meal has 2 alternatives (normal + budget-friendly)
- User tries first option → likes it → marks as selected
- App remembers user preferences
- Future recommendations can be personalized based on selections

#### B. **Track User Choices**
- Which meals do users actually prepare?
- Cost-effective vs normal options preference
- Regional preference patterns
- Data for improving AI recommendations

### Real-World Scenarios:

**Scenario 1: Trying Alternatives**
```
User sees 2 breakfast options:
Option 1: Poha with vegetables (₹20)
Option 2: Ragi porridge (₹10) ✓ Selected

System learns: This user prefers budget options
Next generation: Prioritize cost-effective suggestions
```

**Scenario 2: Family Preferences**
```
User tries Suggestion 1 → Family doesn't like it
User tries Suggestion 2 → Everyone loves it ✓ Selected

System learns: Family taste preferences
Future plans: Include similar recipes
```

### Technical Implementation:
```typescript
PUT /api/mealplan/suggestion/:suggestionId
Body: {
  isSelected: true
}
```

---

## 4. **DELETE - Remove Meal Plans**

### Why It's Needed:

#### A. **Clean Up Old Data**
- Storage management (old plans take space)
- Keep database performant
- Focus on relevant recent plans

#### B. **Soft Delete for History**
- Don't actually delete (set `isActive: false`)
- User can "archive" old plans
- Maintain data for analytics
- Recover if needed

#### C. **User Control**
- User doesn't like a generated plan → Delete it
- Generated by mistake → Remove it
- Privacy: User wants to clear history

### Real-World Scenarios:

**Scenario 1: Irrelevant Plan**
```
User accidentally generates plan → Realizes mistake
→ Deletes the wrong plan → Generates correct one
```

**Scenario 2: Monthly Cleanup**
```
App suggests: "Archive meal plans older than 30 days?"
User confirms → Old plans archived (soft delete)
Database stays clean and fast
```

**Scenario 3: Privacy**
```
User changing phone/account
Wants to clear all meal history
Deletes all plans → Fresh start
```

### Technical Implementation:
```typescript
DELETE /api/mealplan/:id
// Soft delete: Sets isActive = false
// Data preserved for analytics
```

---

## Complete User Journey Example

### Week 1 - First Trimester

**Monday Morning:**
1. **CREATE**: User opens app, generates meal plan
   - AI creates breakfast/lunch/dinner/snack suggestions
   - 2 alternatives per meal (8 total suggestions)
   - Saved to database with meal plan ID

2. **READ**: User views breakfast suggestions
   - Option 1: Poha with vegetables
   - Option 2: Ragi porridge

3. **UPDATE**: User tries Option 2, marks it selected
   - System records preference
   - Learning user likes budget-friendly options

**Throughout the Week:**
4. **READ**: User checks meal plan daily
   - Refers to cooking instructions
   - Reviews nutrition facts
   - Shares with family

**Next Monday:**
5. **CREATE**: Generate new plan for Week 2
   - AI considers: Previous selections (Ragi porridge ✓)
   - Generates similar cost-effective options
   - New variety while respecting preferences

**Month End:**
6. **READ**: Review entire month's meal history
   - See nutrition variety
   - Identify favorite meals
   - Share with doctor

7. **DELETE**: Archive plans older than 30 days
   - Keep recent 4 weeks
   - Clean up database

---

## Why Not Just "Recommend and Forget"?

### ❌ Without CRUD (Recommendation Only):
```
User gets meal suggestions → Closes app → Suggestions lost
Next day → Need to remember what was suggested
No history → Can't track eating patterns
No preferences → Same random suggestions every time
No improvement → AI can't learn from user
```

### ✅ With Full CRUD:
```
User gets meal suggestions → Saved in database
Can view anytime → Access from any device
History available → Track nutrition over time
Preferences saved → AI learns and improves
Better experience → Personalized recommendations
```

---

## Database Design Supporting CRUD

### MealPlan Table
```prisma
model MealPlan {
  id          String   @id
  userId      String   // Who owns this plan
  title       String   // "Daily Meal Plan - Oct 11"
  date        DateTime // Date for this plan
  isActive    Boolean  // For soft delete
  createdAt   DateTime
  
  suggestions MealSuggestion[] // One-to-many relation
}
```

### MealSuggestion Table
```prisma
model MealSuggestion {
  id          String   @id
  mealPlanId  String   // Foreign key
  type        MealType // BREAKFAST, LUNCH, DINNER, SNACK
  content     String   // JSON: {name, why, benefits, facts, steps}
  orderIndex  Int      // 0 = first option, 1 = second option
  isSelected  Boolean  // User marked this as preferred
  createdAt   DateTime
  
  mealPlan    MealPlan @relation(...)
}
```

### Why This Structure?

1. **One-to-Many Relation**: One plan has many suggestions
2. **Flexibility**: Each suggestion is independent
3. **User Tracking**: `isSelected` field tracks preferences
4. **Order Maintenance**: `orderIndex` keeps alternatives organized
5. **Soft Delete**: `isActive` flag preserves data

---

## Analytics Benefits

With CRUD operations, we can analyze:

### User Behavior:
- Which meals are most selected?
- Cost-effective vs normal preferences?
- Regional meal preferences?
- Seasonal ingredient acceptance?

### Health Outcomes:
- Correlation between meal choices and health?
- Nutrition variety across trimesters?
- Compliance with recommendations?

### System Improvement:
- Which AI suggestions work best?
- How to improve prompt engineering?
- What ingredients to prioritize?

---

## API Usage Examples

### Complete Flow:

```javascript
// Day 1: Generate fresh meal plan
const response = await fetch('/api/mealplan/generate', {
  method: 'POST',
  body: JSON.stringify({
    userId: 'user_123',
    userProfile: 'Second trimester, vegetarian'
  })
});
const plan = await response.json();
// Returns: 8 meal suggestions grouped by type

// User tries breakfast option 2
await fetch(`/api/mealplan/suggestion/${breakfastOption2Id}`, {
  method: 'PUT',
  body: JSON.stringify({ isSelected: true })
});

// Later: View all meal history
const history = await fetch('/api/mealplan?userId=user_123');
// Returns: Last 10 meal plans

// Week later: Generate new plan (AI considers previous selections)
const newPlan = await fetch('/api/mealplan/generate', {
  method: 'POST',
  body: JSON.stringify({
    userId: 'user_123',
    userProfile: 'Second trimester, vegetarian'
  })
});

// Month later: Clean up old plans
await fetch(`/api/mealplan/${oldPlanId}`, {
  method: 'DELETE'
});
```

---

## Summary

CRUD operations are essential because:

1. ✅ **Users need persistent access** to meal plans
2. ✅ **Plans must be stored** for reference while cooking
3. ✅ **History is valuable** for tracking and learning
4. ✅ **Preferences improve** future recommendations
5. ✅ **Analytics help** improve the system
6. ✅ **Data management** keeps system clean and fast

This isn't just about showing recommendations—it's about creating a **personalized, learning, improving meal planning system** that genuinely helps rural women maintain healthy nutrition throughout their pregnancy journey.
